diff --git a/components/history/core/browser/url_database.cc b/components/history/core/browser/url_database.cc
index 95ea8b5b246ca..a637c17551f9d 100644
--- a/components/history/core/browser/url_database.cc
+++ b/components/history/core/browser/url_database.cc
@@ -4,6 +4,7 @@
 
 #include "components/history/core/browser/url_database.h"
 
+#include <cctype>
 #include <string>
 #include <vector>
 
@@ -312,46 +313,104 @@ bool URLDatabase::AutocompleteForPrefix(const std::string& prefix,
                                         size_t max_results,
                                         bool typed_only,
                                         URLRows* results) {
-  // NOTE: this query originally sorted by starred as the second parameter. But
-  // as bookmarks is no longer part of the db we no longer include the order
-  // by clause.
+  // MODIFIED: Split the query into separate queries for lowercase and uppercase
+  // to ensure case-sensitive matching. The original range query could match
+  // case-insensitively due to how SQLite's binary comparison works with ranges.
+  // By splitting into two queries (one for lowercase prefix, one for uppercase),
+  // we ensure only exact case-sensitive matches are returned.
   results->clear();
 
-  sql::Statement statement;
-  if (typed_only) {
-    statement.Assign(GetDB().GetCachedStatement(
-        SQL_FROM_HERE,
-        "SELECT" HISTORY_URL_ROW_FIELDS
-        "FROM urls "
-        "WHERE url >= ? AND url < ? AND hidden = 0 AND typed_count > 0 "
-        "ORDER BY typed_count DESC, visit_count DESC, last_visit_time DESC "
-        "LIMIT ?"));
-  } else {
-    statement.Assign(GetDB().GetCachedStatement(
-        SQL_FROM_HERE,
-        "SELECT" HISTORY_URL_ROW_FIELDS
-        "FROM urls "
-        "WHERE url >= ? AND url < ? AND hidden = 0 "
-        "ORDER BY typed_count DESC, visit_count DESC, last_visit_time DESC "
-        "LIMIT ?"));
-  }
+  // Helper lambda to execute a single case-specific query
+  auto execute_query = [this, typed_only, max_results](const std::string& case_prefix, URLRows* case_results) {
+    sql::Statement statement;
+    if (typed_only) {
+      statement.Assign(GetDB().GetCachedStatement(
+          SQL_FROM_HERE,
+          "SELECT" HISTORY_URL_ROW_FIELDS
+          "FROM urls "
+          "WHERE url >= ? AND url < ? AND hidden = 0 AND typed_count > 0 "
+          "ORDER BY typed_count DESC, visit_count DESC, last_visit_time DESC "
+          "LIMIT ?"));
+    } else {
+      statement.Assign(GetDB().GetCachedStatement(
+          SQL_FROM_HERE,
+          "SELECT" HISTORY_URL_ROW_FIELDS
+          "FROM urls "
+          "WHERE url >= ? AND url < ? AND hidden = 0 "
+          "ORDER BY typed_count DESC, visit_count DESC, last_visit_time DESC "
+          "LIMIT ?"));
+    }
 
-  // We will find all strings between "prefix" and this string, which is prefix
-  // followed by the maximum character size. Use 8-bit strings for everything
-  // so we can be sure sqlite is comparing everything in 8-bit mode. Otherwise,
-  // it will have to convert strings either to UTF-8 or UTF-16 for comparison.
-  std::string end_query = database_utils::UpperBoundString(prefix);
+    std::string end_query = database_utils::UpperBoundString(case_prefix);
+    statement.BindString(0, case_prefix);
+    statement.BindString(1, end_query);
+    statement.BindInt(2, static_cast<int>(max_results));
 
-  statement.BindString(0, prefix);
-  statement.BindString(1, end_query);
-  statement.BindInt(2, static_cast<int>(max_results));
+    while (statement.Step()) {
+      URLRow info;
+      if (FillURLRow(statement, &info)) {
+        case_results->push_back(info);
+      }
+    }
+  };
 
-  while (statement.Step()) {
-    URLRow info;
-    if (FillURLRow(statement, &info)) {
-      results->push_back(info);
+  // MODIFIED: Split the query into separate queries for lowercase and uppercase
+  // versions of the prefix to ensure we catch all potential matches, then filter
+  // to only include case-sensitive matches in history_url_provider.cc.
+  // 
+  // The range query uses SQLite's binary comparison which is case-sensitive,
+  // but by querying for both lowercase and uppercase versions, we ensure we
+  // don't miss any matches. The filtering step will then ensure only the
+  // case-sensitive match is included.
+  if (prefix.empty()) {
+    // Empty prefix - just do one query
+    execute_query(prefix, results);
+    return !results->empty();
+  }
+
+  // Find the last alphabetic character in the prefix to split
+  size_t last_alpha_pos = std::string::npos;
+  for (size_t i = prefix.length(); i > 0; --i) {
+    if (std::isalpha(static_cast<unsigned char>(prefix[i - 1]))) {
+      last_alpha_pos = i - 1;
+      break;
     }
   }
+  
+  if (last_alpha_pos == std::string::npos) {
+    // No alphabetic characters - just query for the exact prefix
+    execute_query(prefix, results);
+    return !results->empty();
+  }
+  
+  // Split prefix at the last alphabetic character
+  std::string base_prefix = prefix.substr(0, last_alpha_pos);
+  char last_char = prefix[last_alpha_pos];
+  std::string suffix = prefix.substr(last_alpha_pos + 1);
+  
+  // Create lowercase and uppercase versions
+  char last_char_lower = static_cast<char>(std::tolower(static_cast<unsigned char>(last_char)));
+  char last_char_upper = static_cast<char>(std::toupper(static_cast<unsigned char>(last_char)));
+  
+  std::string prefix_lower = base_prefix + last_char_lower + suffix;
+  std::string prefix_upper = base_prefix + last_char_upper + suffix;
+  
+  // Execute both queries and combine results
+  URLRows results_lower, results_upper;
+  execute_query(prefix_lower, &results_lower);
+  if (prefix_lower != prefix_upper) {
+    execute_query(prefix_upper, &results_upper);
+  }
+  
+  // Combine results
+  results->reserve(results_lower.size() + results_upper.size());
+  results->insert(results->end(), results_lower.begin(), results_lower.end());
+  results->insert(results->end(), results_upper.begin(), results_upper.end());
+  
+  // Note: We don't truncate here because the filtering in history_url_provider.cc
+  // will remove non-matching entries, and we want to ensure we have enough
+  // candidates to filter from.
+  
   return !results->empty();
 }
 
diff --git a/components/omnibox/browser/autocomplete_result.cc b/components/omnibox/browser/autocomplete_result.cc
index 9cb1d78b74b6f..0689545584ae4 100644
--- a/components/omnibox/browser/autocomplete_result.cc
+++ b/components/omnibox/browser/autocomplete_result.cc
@@ -315,40 +315,39 @@ void AutocompleteResult::Sort(
 
   DeduplicateMatches(input, template_url_service);
 
-  // CRITICAL FILTER: Remove any matches whose destination URL doesn't contain
-  // the current input text case-sensitively. This prevents matches from any
-  // provider (HistoryURLProvider, ShortcutsProvider, BookmarkProvider, etc.)
-  // from appearing in the dropdown when they don't match the user's typed input.
-  // 
-  // Example: User types "flag=F16" but a match has "flag=f16" -> filtered out
-  //          User types "flag=F16" and match has "flag=F16" -> kept
-  //
-  // This is a final safeguard to ensure only matches that actually contain the
-  // user's input (case-sensitively) appear in the dropdown.
+  // Case-sensitive URL filtering for URL matches (history, bookmarks, etc.)
+  // IMPORTANT: Skip search-type matches because their URLs encode the query
+  // (e.g., spaces become %20, quotes become %22), so the literal input won't match.
   if (!input.text().empty()) {
     std::u16string input_text = input.text();
     std::string input_text_utf8 = base::UTF16ToUTF8(input_text);
-    matches_.erase(
-        std::remove_if(matches_.begin(), matches_.end(),
-                       [&input_text_utf8](const AutocompleteMatch& match) {
-                         if (match.destination_url.is_empty() || !match.destination_url.is_valid()) {
-                           return false;  // Keep matches without URLs (e.g., search suggestions)
-                         }
-                         std::string url_spec = match.destination_url.spec();
-                         // Check if URL contains the input text case-sensitively
-                         size_t pos = url_spec.find(input_text_utf8);
-                         if (pos == std::string::npos) {
-                           // Input text not found in URL (case-sensitive) - filter it out
-                           return true;  // Remove this match
-                         }
-                         // Verify it's an exact match (not just a substring with different case)
-                         std::string found_substring = url_spec.substr(pos, input_text_utf8.length());
-                         if (found_substring != input_text_utf8) {
-                           return true;  // Remove this match
-                         }
-                         return false;  // Keep this match
-                       }),
-        matches_.end());
+    
+    // Only apply case-sensitive filtering if input looks like a URL (no spaces)
+    bool input_has_spaces = (input_text.find(u' ') != std::u16string::npos) ||
+                            (input_text.find(u'\t') != std::u16string::npos);
+    
+    if (!input_has_spaces && input.type() != metrics::OmniboxInputType::QUERY) {
+      matches_.erase(
+          std::remove_if(matches_.begin(), matches_.end(),
+                         [&input_text_utf8](const AutocompleteMatch& match) {
+                           // Skip search-type matches - they encode query params
+                           if (AutocompleteMatch::IsSearchType(match.type)) {
+                             return false;  // Keep search matches
+                           }
+                           if (match.destination_url.is_empty() || !match.destination_url.is_valid()) {
+                             return false;  // Keep matches without URLs
+                           }
+                           std::string url_spec = match.destination_url.spec();
+                           // Check if URL contains the input text case-sensitively
+                           size_t pos = url_spec.find(input_text_utf8);
+                           if (pos == std::string::npos) {
+                             // Input text not found in URL (case-sensitive) - filter it out
+                             return true;  // Remove this match
+                           }
+                           return false;  // Keep this match
+                         }),
+          matches_.end());
+    }
   }
 
   // Sort the matches by relevance and demotions.
@@ -361,56 +360,35 @@ void AutocompleteResult::Sort(
   if (default_match_to_preserve &&
       (top_match == matches_.end() ||
        top_match->type != AutocompleteMatchType::URL_WHAT_YOU_TYPED)) {
-    // MODIFIED: Check if the preserved match's URL contains the current input text
-    // (case-sensitively). If the user changes 'f' to 'F', and the preserved match has 'f16',
-    // then 'F' is not in 'f16' (case-sensitively), so we shouldn't preserve it.
-    // This is an additional safeguard to prevent preserving matches that don't match
-    // the current input case-sensitively.
-    std::string preserved_url = default_match_to_preserve->destination_url.spec();
+    // Check if this is a URL-like input (no spaces, not QUERY type).
+    // Only apply case-sensitive URL matching for URL inputs.
+    // For search queries (spaces, QUERY type), use standard matching.
     std::u16string input_text = input.text();
-    std::string input_text_utf8 = base::UTF16ToUTF8(input_text);
+    bool is_url_input = (input.type() != metrics::OmniboxInputType::QUERY) &&
+                        (input_text.find(u' ') == std::u16string::npos) &&
+                        (input_text.find(u'\t') == std::u16string::npos);
+    
+    bool should_try_preserve = true;
     
-    // Check if the preserved URL contains the current input text (case-sensitively)
-    // If it doesn't, don't preserve the match. This prevents preserving a match
-    // when the user changes the case of characters in their input.
-    bool preserved_url_contains_input = false;
-    if (!input_text_utf8.empty()) {
-      // Search for the input text in the preserved URL (case-sensitive)
+    // Only apply case-sensitive URL check for URL inputs and non-search matches
+    if (is_url_input && !input_text.empty() &&
+        !AutocompleteMatch::IsSearchType(default_match_to_preserve->type)) {
+      std::string preserved_url = default_match_to_preserve->destination_url.spec();
+      std::string input_text_utf8 = base::UTF16ToUTF8(input_text);
+      
+      // Check if the preserved URL contains the current input text (case-sensitively)
       size_t pos = preserved_url.find(input_text_utf8);
-      if (pos != std::string::npos) {
-        // Found the input text - verify it's an exact match
-        std::string found_substring = preserved_url.substr(pos, input_text_utf8.length());
-        if (found_substring == input_text_utf8) {
-          preserved_url_contains_input = true;
-        }
+      if (pos == std::string::npos) {
+        // Input text not found in URL - don't preserve for URL inputs
+        should_try_preserve = false;
       }
     }
     
-    // Only try to preserve if the preserved URL contains the current input (case-sensitively)
-    if (preserved_url_contains_input) {
+    if (should_try_preserve) {
       const auto default_match_fields =
           GetMatchComparisonFields(default_match_to_preserve.value());
       const auto preserved_default_match =
           std::ranges::find_if(matches_, [&](const AutocompleteMatch& match) {
-            // Find a duplicate match. Don't preserve suggestions that are not
-            // default-able; e.g., typing 'xy' shouldn't preserve default
-            // 'xz.com/xy'.
-            // MODIFIED: Also check that the destination URLs match exactly (case-sensitive).
-            // This prevents preserving a match that differs only in case from the current input.
-            // For example, if the user changes "flag=f16" to "flag=F16", we should not preserve
-            // the "flag=f16" match even if the stripped URLs are the same.
-            // 
-            // CRITICAL: The destination URL must match EXACTLY (case-sensitive). This is the
-            // most important check - if the URLs differ in case, we must not preserve the match.
-            // This prevents the lowercase version from being preserved when the user changes
-            // 'f' to 'F' in their input.
-            bool urls_match_exact = (default_match_to_preserve->destination_url.spec() == 
-                                     match.destination_url.spec());
-            if (!urls_match_exact) {
-              // URLs don't match exactly (case-sensitive) - don't preserve
-              return false;
-            }
-            // URLs match exactly - now check other fields
             bool fields_match = default_match_fields == GetMatchComparisonFields(match);
             return fields_match && match.allowed_to_be_default_match;
           });
@@ -418,8 +396,6 @@ void AutocompleteResult::Sort(
         top_match = preserved_default_match;
       }
     }
-    // If preserved_url_contains_input is false, we don't try to preserve the match
-    // This prevents preserving a match when the user changes the case of characters
   }
 
   RotateMatchToFront(top_match, &matches_);
diff --git a/components/omnibox/browser/history_url_provider.cc b/components/omnibox/browser/history_url_provider.cc
index fe1adca171eb7..a9cdf568a044b 100644
--- a/components/omnibox/browser/history_url_provider.cc
+++ b/components/omnibox/browser/history_url_provider.cc
@@ -489,19 +489,27 @@ void HistoryURLProvider::Start(const AutocompleteInput& input,
   // safety issues).  At that point it's just as fast, and easier, to simply
   // re-run the query from scratch and ignore `minimal_changes`.
 
-  // Cancel any in-progress query.
-  // MODIFIED: Always clear matches when starting a new query to ensure old matches
-  // (especially case-different ones) don't persist.
-  Stop(AutocompleteStopReason::kClobbered);
-  // Double-check that matches are cleared - this is critical for case-sensitive matching
-  if (!matches_.empty()) {
-    matches_.clear();
-  }
   if (input.IsZeroSuggest() ||
       (input.type() == metrics::OmniboxInputType::EMPTY)) {
     return;
   }
 
+  // Cancel any in-progress query first.
+  // This is critical - we must cancel async work before checking for queries,
+  // otherwise the async work might complete and overwrite our state.
+  Stop(AutocompleteStopReason::kClobbered);
+
+  // CRITICAL: If the input contains spaces, it's a search query, not a URL.
+  // HistoryURLProvider should not process search queries - let SearchProvider handle them.
+  std::u16string input_text = input.text();
+  if (input_text.find(u' ') != std::u16string::npos ||
+      input_text.find(u'\t') != std::u16string::npos ||
+      input.type() == metrics::OmniboxInputType::QUERY) {
+    // This is a query - don't process it.
+    // Stop() already set done_ = true and cleared matches_.
+    return;
+  }
+
   // Remove the keyword from input if we're in keyword mode for a starter pack
   // engine.
   const auto [autocomplete_input, starter_pack_engine] =
@@ -587,6 +595,7 @@ void HistoryURLProvider::Start(const AutocompleteInput& input,
       default_search_provider, search_terms_data,
       client()->AllowDeletingBrowserHistory(), starter_pack_engine));
 
+
   // Pass 1: Get the in-memory URL database, and use it to find and promote
   // the inline autocomplete match, if any.
   history::URLDatabase* url_db = history_service->InMemoryDatabase();
@@ -689,6 +698,23 @@ void HistoryURLProvider::ExecuteWithDB(HistoryURLProviderParams* params,
 void HistoryURLProvider::DoAutocomplete(history::HistoryBackend* backend,
                                         history::URLDatabase* db,
                                         HistoryURLProviderParams* params) {
+  // CRITICAL: If the input contains spaces, it's a search query, not a URL.
+  // Skip all URL matching for queries with spaces. SearchProvider handles these.
+  // Check both fixed-up input and original input (before fixup) because
+  // fixup may remove trailing spaces.
+  std::u16string input_text = params->input.text();
+  std::u16string original_input = params->input_before_fixup.text();
+  if (input_text.find(u' ') != std::u16string::npos ||
+      input_text.find(u'\t') != std::u16string::npos ||
+      original_input.find(u' ') != std::u16string::npos ||
+      original_input.find(u'\t') != std::u16string::npos ||
+      params->input.type() == metrics::OmniboxInputType::QUERY ||
+      params->input_before_fixup.type() == metrics::OmniboxInputType::QUERY) {
+    // This is a query - don't process it. Just return with empty matches.
+    params->matches.clear();
+    return;
+  }
+
   // Get the matching URLs from the DB.
   params->matches.clear();
   history::URLRows url_matches;
@@ -741,6 +767,7 @@ void HistoryURLProvider::DoAutocomplete(history::HistoryBackend* backend,
         // will be correctly filtered out.
         bool is_case_sensitive_match = false;
         
+        
         // PRIMARY CHECK: Does the URL contain the input text as a substring (case-sensitive)?
         // This is the most important check - it catches all cases.
         // CRITICAL: std::u16string::find() is case-sensitive, so "f" will NOT match "F".
diff --git a/components/omnibox/browser/omnibox_edit_model.cc b/components/omnibox/browser/omnibox_edit_model.cc
index c7f7e1d95e5ce..c19f7fd7cd244 100644
--- a/components/omnibox/browser/omnibox_edit_model.cc
+++ b/components/omnibox/browser/omnibox_edit_model.cc
@@ -2318,6 +2318,69 @@ void OmniboxEditModel::AcceptInput(WindowOpenDisposition disposition,
   // Get the URL and transition type for the selected entry.
   GURL alternate_nav_url;
   AutocompleteMatch match = CurrentMatch(&alternate_nav_url);
+  
+  // MODIFIED: Always use the exact text the user typed, not a history match.
+  // This ensures that when the user types a URL, pressing Enter will send the
+  // exact URL they typed to the server, not a history match (even if it matches).
+  // IMPORTANT: Only apply this for URL matches, not for search queries.
+  // Search queries should use the normal search match handling.
+  std::u16string current_text = GetText();
+  if (!current_text.empty() && (user_input_in_progress_ || has_temporary_text_)) {
+    // Check if the current match is a search query - if so, don't override it
+    // CRITICAL: Text containing spaces should be treated as a search query.
+    // This ensures multi-word queries work correctly and aren't incorrectly
+    // treated as URLs, which would cause the omnibox to become inactive.
+    bool text_has_spaces = (current_text.find(u' ') != std::u16string::npos);
+    bool is_search_query = (match.type == AutocompleteMatchType::SEARCH_WHAT_YOU_TYPED ||
+                            match.type == AutocompleteMatchType::SEARCH_SUGGEST ||
+                            match.type == AutocompleteMatchType::SEARCH_SUGGEST_ENTITY ||
+                            match.type == AutocompleteMatchType::SEARCH_SUGGEST_TAIL ||
+                            match.type == AutocompleteMatchType::SEARCH_SUGGEST_PERSONALIZED ||
+                            match.type == AutocompleteMatchType::SEARCH_SUGGEST_PROFILE ||
+                            input_.type() == metrics::OmniboxInputType::QUERY ||
+                            text_has_spaces);
+    
+    // Only apply verbatim match override for URL matches, not search queries
+    if (!is_search_query) {
+      std::u16string text_with_keyword = MaybePrependKeyword(current_text);
+      
+      // Construct the URL directly from the user's text to preserve exact case.
+      // Don't use canonicalized_url() as it might normalize the case.
+      GURL user_url(base::UTF16ToUTF8(text_with_keyword));
+      
+      // If the URL is valid, create a verbatim match using the exact URL the user typed.
+      // This ensures the exact text (including case) is always sent to the server.
+      if (user_url.is_valid()) {
+        AutocompleteInput verbatim_input(
+            current_text, input_.cursor_position(),
+            input_.current_page_classification(),
+            controller_->client()->GetSchemeClassifier(),
+            controller_->client()->ShouldDefaultTypedNavigationsToHttps(),
+            controller_->client()->GetHttpsPortForTesting(),
+            controller_->client()->IsUsingFakeHttpsForHttpsUpgradeTesting());
+        verbatim_input.set_prevent_inline_autocomplete(true);
+        verbatim_input.set_prefer_keyword(input_.prefer_keyword());
+        verbatim_input.set_keyword_mode_entry_method(input_.keyword_mode_entry_method());
+        verbatim_input.set_allow_exact_keyword_match(input_.allow_exact_keyword_match());
+        verbatim_input.set_omit_asynchronous_matches(true);
+        verbatim_input.set_focus_type(input_.focus_type());
+        
+        // Create a verbatim match using the exact URL the user typed (preserving case)
+        AutocompleteMatch verbatim_match = VerbatimMatchForInput(
+            autocomplete_controller()->history_url_provider(),
+            autocomplete_controller()->autocomplete_provider_client(),
+            verbatim_input, user_url, false);
+        
+        // Override the destination URL with the exact URL the user typed to preserve case
+        verbatim_match.destination_url = user_url;
+        verbatim_match.fill_into_edit = text_with_keyword;
+        
+        // Always use the verbatim match. This ensures the user's exact text is used.
+        match = verbatim_match;
+        alternate_nav_url = GURL();
+      }
+    }
+  }
 
   // If CTRL is down it means the user wants to append ".com" to the text they
   // typed. If we can successfully generate a URL_WHAT_YOU_TYPED match doing
